<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kewnric's Ultimate Learning Tool</title>
  <link id="favicon" rel="icon" href="https://placehold.co/32x32/2e5353/d1ba8d?text=KL">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
      background-color: #1a202c; /* Dark Slate Blue */
      background-image: url('Background.jpg');
      background-repeat: no-repeat;
      background-attachment: fixed;
      background-position: center top;
      background-size: cover;
      color: #e2e8f0; /* Light Slate Gray */
      transition: background-color 0.3s ease;
    }

    h1, h2 {
      color: #f6e05e; /* Saffron Yellow */
      text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
    }
    h2.section-title {
        color: #9f7aea; /* Purple */
    }

    .controls-container, .section-controls-header, .section-controls-footer {
      margin-bottom: 1.25rem; /* 20px */
      display: flex;
      flex-wrap: wrap;
      gap: 0.625rem; /* 10px */
      align-items: center;
      padding: 0.75rem; /* 12px */
      background-color: rgba(45, 55, 72, 0.7); /* Darker Gray-Blue, semi-transparent */
      border-radius: 0.5rem; /* 8px */
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
    }

    button, input[type="button"], input[type="submit"] {
      padding: 0.625rem 0.9375rem; /* 10px 15px */
      background-color: #4299e1; /* Tailwind Blue 500 */
      color: white;
      border: none;
      border-radius: 0.5rem; /* 8px */
      cursor: pointer;
      font-weight: 600;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
    }
    button:hover, input[type="button"]:hover, input[type="submit"]:hover {
      background-color: #3182ce; /* Tailwind Blue 600 */
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }
    button:active, input[type="button"]:active, input[type="submit"]:active {
      background-color: #2b6cb0; /* Tailwind Blue 700 */
      box-shadow: none;
      transform: translateY(1px);
    }
    button.danger { background-color: #e53e3e; /* Tailwind Red 500 */ }
    button.danger:hover { background-color: #c53030; /* Tailwind Red 600 */ }
    button.warning { background-color: #ecc94b; color: #1a202c; /* Tailwind Yellow 400 */ }
    button.warning:hover { background-color: #d69e2e; /* Tailwind Yellow 500 */ }
    button.success { background-color: #48bb78; /* Tailwind Green 500 */ }
    button.success:hover { background-color: #38a169; /* Tailwind Green 600 */ }


    .section {
      background-color: rgba(74, 85, 104, 0.85); /* Gray-Blue, semi-transparent */
      color: #cbd5e0; /* Lighter Slate Gray */
      border: 1px solid #f6e05e; /* Saffron Yellow */
      border-radius: 0.75rem; /* 12px */
      padding: 1.25rem; /* 20px */
      margin-bottom: 1.5rem; /* 24px */
      box-shadow: 0 10px 15px -3px rgba(0,0,0,0.2), 0 4px 6px -2px rgba(0,0,0,0.1);
      transition: box-shadow 0.3s ease;
    }
    .section:hover {
      box-shadow: 0 20px 25px -5px rgba(0,0,0,0.2), 0 10px 10px -5px rgba(0,0,0,0.1);
    }
    .section h2.editable {
        border: 1px dashed #cbd5e0;
        padding: 5px;
        cursor: text;
    }

    input[type="text"], input[type="number"], textarea, select {
      padding: 0.5rem 0.75rem; /* 8px 12px */
      border-radius: 0.5rem; /* 8px */
      border: 1px solid #4a5568; /* Gray 600 */
      font-size: 1rem;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
      color: #1a202c; /* Dark text for inputs */
      background-color: #edf2f7; /* Gray 200 */
    }
    input[type="text"]:focus, input[type="number"]:focus, textarea:focus, select:focus {
      outline: none;
      border-color: #4299e1; /* Blue 500 */
      box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
    }
    textarea.key-input {
      width: calc(100% - 24px);
      height: 80px;
      margin-bottom: 10px;
    }
    textarea.extraction-input {
        width: 100%;
        min-height: 100px;
        margin-bottom: 10px;
    }

    table {
      background-color: #2d3748; /* Gray 800 */
      color: #e2e8f0; /* Light Slate Gray */
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      margin-bottom: 1rem; /* 16px */
      border-radius: 0.75rem; /* 12px */
      overflow: hidden; /* Important for rounded corners on table */
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.15), 0 2px 4px -1px rgba(0,0,0,0.1);
    }
    th, td {
      border: 1px solid #4a5568; /* Gray 600 */
      text-align: center;
      padding: 0.75rem 1rem; /* 12px 16px */
      font-size: 0.95rem;
    }
    th {
      background-color: #4a5568; /* Gray 600 */
      font-weight: 600;
      color: #f6e05e; /* Saffron Yellow for header text */
    }
    td label {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 36px;
      cursor: pointer;
      padding: 0;
    }
     td input[type="radio"] {
      margin: 0;
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: #4299e1; /* Blue 500 for radio button */
    }
    td.question-text-cell {
        text-align: left;
        word-break: break-word;
        min-width: 200px; /* Give some space for question text */
    }

    .hidden { display: none !important; }
    .correct { background-color: #38a169 !important; color: #e2e8f0 !important; } /* Green 600 */
    .wrong { background-color: #c53030 !important; color: #e2e8f0 !important; }   /* Red 600 */
    .selected { background-color: #3182ce !important; } /* Blue 600 for selected */
    .actual-correct { box-shadow: 0 0 0 3px #48bb78 inset !important; } /* Green 500 outline */
    .overdue .timerDisplay { color: #e53e3e; font-weight: bold; } /* Red 500 */
    .overdue { border: 2px solid #e53e3e; } /* Red 500 */


    #recordsContainer { margin-top: 1.5rem; /* 24px */ }
    #recordsTable th, #recordsTable td { padding: 0.75rem 1rem; }
    #recordsTable button { padding: 0.375rem 0.75rem; font-size: 0.9em; }

    .output-display {
      margin-top: 1rem; /* 16px */
      font-weight: bold;
      font-size: 1.15rem;
      color: #e2e8f0;
      padding: 0.75rem; /* 12px */
      background-color: rgba(45, 55, 72, 0.5); /* Darker Gray-Blue, semi-transparent */
      border-radius: 0.375rem; /* 6px */
    }

    .timer-input { width: 70px; margin-left: 5px; }
    .timerDisplay { margin-left: 10px; font-weight: bold; }
    .question-input-field { width: 60px; margin-right: 5px;}

    /* Modal styles */
    .modal {
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.6);
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .modal-content {
        background-color: #2d3748; /* Gray 800 */
        margin: auto;
        padding: 20px;
        border: 1px solid #4a5568; /* Gray 600 */
        border-radius: 8px;
        width: 90%;
        max-width: 500px;
        color: #e2e8f0;
    }
    .modal-content h3 { color: #f6e05e; }
    .modal-content button { margin-top: 10px; }

    /* Loading spinner */
    .loader {
      border: 5px solid #4a5568; /* Gray 600 */
      border-top: 5px solid #4299e1; /* Blue 500 */
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 10px auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    #authStatus {
        position: fixed;
        top: 10px;
        right: 10px;
        background-color: rgba(45, 55, 72, 0.9);
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 0.9em;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    #authStatus.loading { color: #ecc94b; }
    #authStatus.error { color: #e53e3e; }
    #authStatus.success { color: #48bb78; }

  </style>
</head>
<body class="p-5 max-w-5xl mx-auto">
  <div id="authStatus" class="loading">Connecting to Firebase...</div>

  <h1 class="text-3xl font-bold text-center mb-2">Kewnric's Ultimate Learning Tool</h1>
  <p class="text-center italic mb-6 text-gray-400">[ Study smart, not just hard! Your User ID will appear here once connected. ]</p>
  <p id="userIdDisplay" class="text-center text-xs text-gray-500 mb-6 break-all"></p>

  <div class="controls-container">
    <label for="sectionNavigator" class="font-semibold">Navigate to Section:</label>
    <select id="sectionNavigator" class="py-2 px-3 rounded-md bg-gray-700 text-white border-gray-600 focus:ring-blue-500 focus:border-blue-500"></select>
  </div>

  <div class="controls-container">
    <input id="newSectionLabel" placeholder="Section Label (e.g., Math Quiz 1)" type="text" class="flex-grow"/>
    <select id="newSectionChoices" class="py-2 px-3 rounded-md bg-gray-700 text-white border-gray-600 focus:ring-blue-500 focus:border-blue-500">
        <option value="5" selected>5 Choices (A-E)</option>
        <option value="4">4 Choices (A-D)</option>
        <option value="3">3 Choices (A-C)</option>
    </select>
    <button id="addSectionBtn" class="success">Add Section</button>
  </div>
  <div class="controls-container">
    <input id="bulkSectionInput" placeholder="Bulk Add: Math 10 | Science 5 (A-E default)" type="text" class="flex-grow"/>
    <button id="confirmBulkAddBtn">Confirm Bulk Add</button>
  </div>

  <div class="controls-container mt-6 p-4 border border-purple-500 rounded-lg">
    <h3 class="text-lg font-semibold text-purple-400 w-full mb-2">AI-Powered Text Extraction</h3>
    <div class="w-full mb-3">
        <label for="textToExtractKey" class="block mb-1 font-medium">Paste text to extract Answer Key:</label>
        <textarea id="textToExtractKey" class="extraction-input" placeholder="Paste text containing questions and answers here. The AI will try to find the answer key (e.g., 1. A, 2. B or A B C D...)."></textarea>
        <label for="targetSectionForKey" class="block mb-1 text-sm">Target Section for Key:</label>
        <select id="targetSectionForKey" class="py-2 px-3 rounded-md bg-gray-700 text-white border-gray-600 focus:ring-blue-500 focus:border-blue-500 w-full mb-2">
            <option value="">-- Select Section --</option>
        </select>
        <button id="extractKeyBtn" class="bg-purple-600 hover:bg-purple-700">Extract Answer Key</button>
    </div>
    <div class="w-full">
        <label for="textToExtractAll" class="block mb-1 font-medium">Paste text to extract Questions & Answer Key:</label>
        <textarea id="textToExtractAll" class="extraction-input" placeholder="Paste full MCQ text here (questions, choices, and key). A new section will be created."></textarea>
        <button id="extractAllBtn" class="bg-purple-600 hover:bg-purple-700">Extract Questions & Key (New Section)</button>
    </div>
    <div id="aiLoadingIndicator" class="loader hidden mt-3"></div>
    <p id="aiStatusMessage" class="text-sm text-gray-400 mt-2"></p>
  </div>


  <div class="controls-container mt-8">
    <button id="toggleRecordsBtn" class="bg-indigo-500 hover:bg-indigo-600">Show Records</button>
    <button id="resetRecordAllBtn" class="warning">Reset & Record All</button>
    <button id="exportRecordsBtn" class="hidden bg-teal-500 hover:bg-teal-600">Export Records to CSV</button>
    <button id="clearAllSectionsBtn" class="danger">Clear All Sections</button>
    <button id="clearAllDataBtn" class="danger">Clear All User Data (from Cloud)</button>
  </div>

  <div id="sectionsContainer" class="mt-6"></div>

  <div id="recordsContainer" class="hidden mt-6">
    <h2 class="text-2xl font-semibold mb-3 text-yellow-400">Attempt History</h2>
    <table id="recordsTable" class="w-full">
      <thead><tr><th>Attempt</th><th>Date | Time</th><th>Details</th><th>Actions</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <div id="customConfirmModal" class="modal hidden">
    <div class="modal-content">
      <h3 id="confirmModalTitle" class="text-xl mb-4">Confirmation</h3>
      <p id="confirmModalMessage" class="mb-5">Are you sure?</p>
      <div class="flex justify-end gap-3">
        <button id="confirmModalYes" class="success">Yes</button>
        <button id="confirmModalNo" class="danger">No</button>
      </div>
    </div>
  </div>


<script type="module">
    // Firebase and App Imports
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, deleteDoc, updateDoc, collection, onSnapshot, query, where, writeBatch, runTransaction, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-analytics.js"; // Added Analytics import

    // --- Global Variables & Firebase Config ---
    const firebaseConfig = {
      apiKey: "AIzaSyDYO79BNxjZj_2nw-ipRFGm8i7Un04UjgE",
      authDomain: "kewnricanswersheet.firebaseapp.com",
      projectId: "kewnricanswersheet",
      storageBucket: "kewnricanswersheet.firebasestorage.app",
      messagingSenderId: "47016270637",
      appId: "1:47016270637:web:d325caff9c1cbf19c451a4",
      measurementId: "G-6QM3ERZFES"
    };
    const appId = 'default-mcq-app'; // Your original 'appId' variable, kept as is

    let db, auth, userId, app, analytics; // Added 'analytics' variable
    let sectionCounter = 0;
    let attemptCounter = 0;
    let records = []; // Local cache, source of truth will be Firestore
    const CHOICES_LABELS = ['A', 'B', 'C', 'D', 'E'];
    let unsubscribeSections = null; // For Firestore listener

    // --- DOM Elements ---
    const sectionsContainer = document.getElementById('sectionsContainer');
    const newSectionLabelInput = document.getElementById('newSectionLabel');
    const newSectionChoicesInput = document.getElementById('newSectionChoices');
    const addSectionBtn = document.getElementById('addSectionBtn');
    const toggleRecordsBtn = document.getElementById('toggleRecordsBtn');
    const exportRecordsBtn = document.getElementById('exportRecordsBtn');
    const resetRecordAllBtn = document.getElementById('resetRecordAllBtn');
    const bulkSectionInput = document.getElementById('bulkSectionInput');
    const confirmBulkAddBtn = document.getElementById('confirmBulkAddBtn');
    const clearAllSectionsBtn = document.getElementById('clearAllSectionsBtn');
    const clearAllDataBtn = document.getElementById('clearAllDataBtn');
    const recordsTableBody = document.querySelector('#recordsTable tbody');
    const recordsContainerEl = document.getElementById('recordsContainer'); // Renamed to avoid conflict
    const sectionNavigator = document.getElementById('sectionNavigator');
    const userIdDisplay = document.getElementById('userIdDisplay');
    const authStatusDiv = document.getElementById('authStatus');

    // AI Extraction Elements
    const textToExtractKey = document.getElementById('textToExtractKey');
    const targetSectionForKey = document.getElementById('targetSectionForKey');
    const extractKeyBtn = document.getElementById('extractKeyBtn');
    const textToExtractAll = document.getElementById('textToExtractAll');
    const extractAllBtn = document.getElementById('extractAllBtn');
    const aiLoadingIndicator = document.getElementById('aiLoadingIndicator');
    const aiStatusMessage = document.getElementById('aiStatusMessage');

    // Modal Elements
    const customConfirmModal = document.getElementById('customConfirmModal');
    const confirmModalTitle = document.getElementById('confirmModalTitle');
    const confirmModalMessage = document.getElementById('confirmModalMessage');
    const confirmModalYes = document.getElementById('confirmModalYes');
    const confirmModalNo = document.getElementById('confirmModalNo');
    let confirmCallback = null;


    // --- Initialization ---
    document.addEventListener('DOMContentLoaded', async () => {
        // Firebase config is now directly in the file, so no need for typeof check
        // if (!firebaseConfig) { // This check is no longer strictly necessary but can remain for safety
        //     showAuthStatus("Firebase config not loaded. App may not work as expected.", "error");
        //     console.error("Firebase config is missing!");
        //     initializeEventListeners(); // Still init some listeners
        //     return;
        // }

        try {
            app = initializeApp(firebaseConfig);
            analytics = getAnalytics(app); // Initialize Analytics
            db = getFirestore(app);
            auth = getAuth(app);
            // setLogLevel('debug'); // For Firebase debugging

            showAuthStatus("Authenticating...", "loading");
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    userIdDisplay.textContent = `User ID: ${userId}`;
                    showAuthStatus(`Authenticated as ${userId.substring(0,8)}...`, "success");
                    await loadStateFromFirestore(); // Load data after user is confirmed
                } else {
                    // If no user, try to sign in.
                    // Use custom token if available, otherwise anonymous
                    try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(auth, __initial_auth_token);
                            // onAuthStateChanged will trigger again with the user
                        } else {
                            await signInAnonymously(auth);
                            // onAuthStateChanged will trigger again with the user
                        }
                    } catch (error) {
                        console.error("Error during sign-in:", error);
                        showAuthStatus("Authentication failed. Please refresh.", "error");
                        userIdDisplay.textContent = "Not authenticated. Data will not be saved.";
                    }
                }
            });
        } catch (e) {
            console.error("Firebase initialization error:", e);
            showAuthStatus("Firebase init error. Try refreshing.", "error");
            userIdDisplay.textContent = "Error connecting to services.";
        }
        
        initializeEventListeners();
    });

    function initializeEventListeners() {
        addSectionBtn.addEventListener('click', () => {
            const label = newSectionLabelInput.value.trim() || `Section ${sectionsContainer.children.length + 1}`;
            const numChoices = parseInt(newSectionChoicesInput.value);
            addSectionToUIAndFirestore(label, numChoices); // Updated function
            newSectionLabelInput.value = '';
        });

        toggleRecordsBtn.addEventListener('click', toggleRecordsVisibility);
        exportRecordsBtn.addEventListener('click', exportRecordsToCSV);
        resetRecordAllBtn.addEventListener('click', () => {
            showCustomConfirm("Reset & Record All", "Are you sure you want to record scores for ALL sections and reset them?", handleResetRecordAll);
        });
        confirmBulkAddBtn.addEventListener('click', handleBulkAdd);
        clearAllSectionsBtn.addEventListener('click', () => {
            showCustomConfirm("Clear All Sections", "Are you sure you want to clear ALL sections? This will remove them from the cloud.", handleClearAllSections);
        });
        clearAllDataBtn.addEventListener('click', () => {
            showCustomConfirm("Clear All User Data", "DANGER! This will delete ALL your data (sections, records) from the cloud. This action is irreversible. Are you absolutely sure?", handleClearAllData);
        });
        sectionNavigator.addEventListener('change', (e) => {
            const sectionId = e.target.value;
            if (sectionId) {
                const sectionElement = document.getElementById(sectionId);
                if (sectionElement) {
                    sectionElement.scrollIntoView({ behavior: 'smooth' });
                }
            }
        });

        extractKeyBtn.addEventListener('click', handleExtractAnswerKey);
        extractAllBtn.addEventListener('click', handleExtractQuestionsAndKey);

        // Modal listeners
        confirmModalYes.addEventListener('click', () => {
            if (confirmCallback) confirmCallback();
            customConfirmModal.classList.add('hidden');
            confirmCallback = null;
        });
        confirmModalNo.addEventListener('click', () => {
            customConfirmModal.classList.add('hidden');
            confirmCallback = null;
        });
    }
    
    function showAuthStatus(message, type = "info") { // type: info, loading, success, error
        authStatusDiv.textContent = message;
        authStatusDiv.className = type; // Resets other classes
    }

    // --- Custom Confirm Modal ---
    function showCustomConfirm(title, message, callback) {
        confirmModalTitle.textContent = title;
        confirmModalMessage.textContent = message;
        confirmCallback = callback;
        customConfirmModal.classList.remove('hidden');
    }

    // --- Firestore Data Path ---
    function getUserDataRef() {
        if (!userId) {
            console.error("User ID is not available for Firestore operation.");
            showAuthStatus("User not authenticated. Cannot save data.", "error");
            return null;
        }
        // Path for private user data
        return doc(db, "artifacts", appId, "users", userId, "mcqData", "appState");
    }
    
    // --- Section Management ---
    async function addSectionToUIAndFirestore(label, numChoices = 5, questionsData = [], key = "", timerState = null, sectionIdOverride = null, questionTexts = []) {
        if (!userId) {
            showCustomConfirm("Error", "You must be authenticated to add sections. Please wait or refresh.", () => {});
            return;
        }

        const localSectionId = sectionIdOverride || `sec${Date.now()}${Math.random().toString(36).substring(2,7)}`; // More unique local ID
        
        const sectionData = {
            id: localSectionId, // This ID is primarily for DOM manipulation and local reference
            label: label,
            numChoices: numChoices,
            key: key,
            questions: questionsData.length > 0 ? questionsData : Array(3).fill({ selected: null, text: "" }), // Default 3 questions
            questionTexts: questionTexts.length > 0 ? questionTexts : Array(3).fill(""),
            timer: timerState || { initialMinutes: null, endTime: null, isPaused: false, remainingTimeOnPause: 0, timeLeft: null },
            createdAt: serverTimestamp(), // For ordering or tracking
            lastModified: serverTimestamp()
        };

        // Optimistically add to UI
        const sectionDiv = addSectionToDOM(sectionData);
        updateSectionNavigator();
        updateTargetSectionForAiKeyExtractionDropdown();


        // Save to Firestore
        const userDocRef = getUserDataRef();
        if (!userDocRef) return;

        try {
            await runTransaction(db, async (transaction) => {
                const userDocSnap = await transaction.get(userDocRef);
                let currentData = userDocSnap.exists() ? userDocSnap.data() : { sections: {}, records: [], sectionCounter: 0, attemptCounter: 0 };
                
                if (!currentData.sections) currentData.sections = {};
                currentData.sections[localSectionId] = sectionData; // Use localSectionId as key in map
                
                // Ensure sectionCounter is robust if loading from an older state
                const maxIdNum = Object.keys(currentData.sections).reduce((max, id) => {
                    const num = parseInt(id.replace('sec',''));
                    return isNaN(num) ? max : Math.max(max, num);
                }, 0);
                currentData.sectionCounter = Math.max(currentData.sectionCounter || 0, maxIdNum, Object.keys(currentData.sections).length);

                transaction.set(userDocRef, currentData, { merge: true });
            });
            console.log("Section added/updated in Firestore:", localSectionId);
        } catch (error) {
            console.error("Error adding section to Firestore: ", error);
            showCustomConfirm("Save Error", "Could not save section to cloud. Please try again.", () => {});
            // Optionally remove the optimistically added UI element or mark it as unsaved
            sectionDiv.style.border = "2px solid red"; // Indicate error
        }
    }


    function addSectionToDOM(sectionData) {
        const { id, label, numChoices, key, questions, timer, questionTexts } = sectionData;
        const sectionDiv = document.createElement('div');
        sectionDiv.className = 'section';
        sectionDiv.id = id; // Use the Firestore-generated ID for the DOM element
        sectionDiv.dataset.numChoices = numChoices;

        sectionDiv.innerHTML = `
            <div class="section-controls-header">
                <h2 class="section-title text-xl font-semibold editable-title" contenteditable="false">${label}</h2>
                <button class="editLabelBtn bg-yellow-500 hover:bg-yellow-600 text-black">Edit Label</button>
                <button class="saveLabelBtn hidden success">Save Label</button>
                <button class="deleteSectionBtn danger">Delete Section</button>
            </div>
            <div class="section-controls-header">
                <input type="number" class="question-input-field" value="${questions.length}" min="1" title="Number of questions">
                <button class="setQCountBtn">Set Q#</button>
                <button class="toggleKeyBtn bg-gray-500 hover:bg-gray-600">Hide Answer Key</button>
            </div>
            <textarea class="key-input" placeholder="1=A\n2=B\n... or A B C D ...">${key}</textarea>
            <button class="checkAnsBtn success">Check Answers</button>
            <table class="mt-3">
                <thead></thead>
                <tbody></tbody>
            </table>
            <div class="output-display"></div>
            <div class="section-controls-footer">
                Timer (min): <input type="number" class="timer-input" min="1" value="${timer ? timer.initialMinutes : ''}"/>
                <button class="timerActionBtn bg-blue-500 hover:bg-blue-600">Start Timer</button>
                <span class="timerDisplay">${timer && timer.timeLeft !== null ? formatTime(timer.timeLeft) : ''}</span>
            </div>
        `;
        sectionsContainer.appendChild(sectionDiv);
        updateTableHeaders(sectionDiv, numChoices);
        setupSectionEventListeners(sectionDiv); // Event listeners for the new section

        // Populate questions and their texts
        setQuestionCountUI(sectionDiv, questions.length, questions.map(q => q.text || ""));
        questions.forEach((q, index) => {
            if (q.selected) {
                const radio = sectionDiv.querySelector(`input[name="${id}_q${index + 1}"][value="${q.selected}"]`);
                if (radio) {
                    radio.checked = true;
                    radio.closest('td').classList.add('selected');
                }
            }
        });
        
        if (timer && timer.endTime) {
            restoreTimer(sectionDiv, timer);
        }
        return sectionDiv;
    }


    function updateTableHeaders(sectionDiv, numChoices) {
        const thead = sectionDiv.querySelector('thead');
        let headerHTML = '<tr><th>#</th><th class="w-2/5">Question Text (Optional)</th>'; // Added Question Text column
        for (let i = 0; i < numChoices; i++) {
            headerHTML += `<th>${CHOICES_LABELS[i]}</th>`;
        }
        headerHTML += '</tr>';
        thead.innerHTML = headerHTML;
    }

    function setupSectionEventListeners(sectionDiv) {
        const sectionId = sectionDiv.id;
        const h2 = sectionDiv.querySelector('h2.editable-title');
        const editLabelBtn = sectionDiv.querySelector('.editLabelBtn');
        const saveLabelBtn = sectionDiv.querySelector('.saveLabelBtn');
        const deleteSectionBtn = sectionDiv.querySelector('.deleteSectionBtn');
        const setQCountBtn = sectionDiv.querySelector('.setQCountBtn');
        const questionInput = sectionDiv.querySelector('.question-input-field');
        const toggleKeyBtn = sectionDiv.querySelector('.toggleKeyBtn');
        const keyTextarea = sectionDiv.querySelector('.key-input');
        const checkAnsBtn = sectionDiv.querySelector('.checkAnsBtn');
        const timerInputAction = sectionDiv.querySelector('.timer-input');
        const timerActionBtn = sectionDiv.querySelector('.timerActionBtn');

        editLabelBtn.addEventListener('click', () => {
            h2.contentEditable = 'true';
            h2.classList.add('border', 'border-yellow-400', 'p-1'); // Visual cue for editing
            h2.focus();
            editLabelBtn.classList.add('hidden');
            saveLabelBtn.classList.remove('hidden');
        });

        const saveLabelAction = async () => {
            h2.contentEditable = 'false';
            h2.classList.remove('border', 'border-yellow-400', 'p-1');
            editLabelBtn.classList.remove('hidden');
            saveLabelBtn.classList.add('hidden');
            await updateSectionFieldInFirestore(sectionId, 'label', h2.textContent.trim());
            updateSectionNavigator(); // Update navigator if label changes
            updateTargetSectionForAiKeyExtractionDropdown();
        };

        saveLabelBtn.addEventListener('click', saveLabelAction);
        h2.addEventListener('blur', () => { if(h2.contentEditable === 'true') saveLabelAction(); });
        h2.addEventListener('keydown', (e) => { if(e.key === 'Enter' && h2.contentEditable === 'true') { e.preventDefault(); saveLabelAction(); } });


        deleteSectionBtn.addEventListener('click', () => {
             showCustomConfirm("Delete Section", `Are you sure you want to delete section "${h2.textContent}"? This will remove it from the cloud.`, async () => {
                if (sectionDiv.timerInterval) clearInterval(sectionDiv.timerInterval);
                
                // Remove from Firestore
                const userDocRef = getUserDataRef();
                if (!userDocRef) return;
                try {
                    await runTransaction(db, async (transaction) => {
                        const userDocSnap = await transaction.get(userDocRef);
                        if (userDocSnap.exists()) {
                            const currentData = userDocSnap.data();
                            if (currentData.sections && currentData.sections[sectionId]) {
                                delete currentData.sections[sectionId];
                                transaction.set(userDocRef, currentData); // Set the modified data back
                            }
                        }
                    });
                    sectionDiv.remove(); // Remove from DOM after successful Firestore deletion
                    updateSectionNavigator();
                    updateTargetSectionForAiKeyExtractionDropdown();
                    console.log("Section deleted from Firestore and DOM:", sectionId);
                } catch (error) {
                    console.error("Error deleting section from Firestore: ", error);
                    showCustomConfirm("Delete Error", "Could not delete section from cloud. Please try again.", () => {});
                }
            });
        });

        setQCountBtn.addEventListener('click', async () => {
            const numToSet = parseInt(questionInput.value) || 1;
            const currentQuestions = Array.from(sectionDiv.querySelectorAll('tbody tr')).map(row => {
                const qTextEl = row.querySelector('.question-text-input');
                return {
                    selected: row.querySelector('input[type="radio"]:checked')?.value || null,
                    text: qTextEl ? qTextEl.value : ""
                };
            });

            const newQuestions = Array(numToSet).fill(null).map((_, i) => {
                return currentQuestions[i] || { selected: null, text: "" };
            });
            
            setQuestionCountUI(sectionDiv, numToSet, newQuestions.map(q => q.text));
            await updateSectionFieldInFirestore(sectionId, 'questions', newQuestions);
            await updateSectionFieldInFirestore(sectionId, 'questionTexts', newQuestions.map(q => q.text));
        });

        toggleKeyBtn.addEventListener('click', () => {
            const isHidden = keyTextarea.classList.toggle('hidden');
            checkAnsBtn.classList.toggle('hidden', isHidden);
            toggleKeyBtn.textContent = isHidden ? 'Show Answer Key' : 'Hide Answer Key';
        });

        checkAnsBtn.addEventListener('click', () => checkAnswers(sectionDiv));

        let lastSelectedRadio = {};
        sectionDiv.addEventListener('click', async (e) => {
            if (e.target.matches('input[type="radio"]')) {
                const radio = e.target;
                const name = radio.name;
                const questionRow = radio.closest('tr');
                const questionIndex = Array.from(sectionDiv.querySelectorAll('tbody tr')).indexOf(questionRow);

                if (lastSelectedRadio[name] === radio && radio.checked) {
                    radio.checked = false;
                    lastSelectedRadio[name] = null;
                } else {
                    lastSelectedRadio[name] = radio;
                }
                sectionDiv.querySelectorAll(`input[name="${name}"]`).forEach(r => r.closest('td').classList.remove('selected'));
                if (radio.checked) radio.closest('td').classList.add('selected');
                
                // Update specific question's selected value in Firestore
                const userDocRef = getUserDataRef();
                if (!userDocRef) return;
                try {
                    await runTransaction(db, async (transaction) => {
                        const docSnap = await transaction.get(userDocRef);
                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            if (data.sections && data.sections[sectionId] && data.sections[sectionId].questions[questionIndex]) {
                                data.sections[sectionId].questions[questionIndex].selected = radio.checked ? radio.value : null;
                                data.sections[sectionId].lastModified = serverTimestamp();
                                transaction.set(userDocRef, data);
                            }
                        }
                    });
                } catch (error) {
                    console.error("Error saving radio state:", error);
                }
            }
        });

        // Save question text on blur
        sectionDiv.addEventListener('blur', async (e) => {
            if (e.target.matches('.question-text-input')) {
                const inputEl = e.target;
                const questionRow = inputEl.closest('tr');
                const questionIndex = Array.from(sectionDiv.querySelectorAll('tbody tr')).indexOf(questionRow);
                const userDocRef = getUserDataRef();
                if (!userDocRef) return;
                try {
                    await runTransaction(db, async (transaction) => {
                        const docSnap = await transaction.get(userDocRef);
                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            if (data.sections && data.sections[sectionId] && data.sections[sectionId].questions[questionIndex]) {
                                data.sections[sectionId].questions[questionIndex].text = inputEl.value;
                                // Also update questionTexts array if you maintain it separately
                                if (data.sections[sectionId].questionTexts) {
                                    data.sections[sectionId].questionTexts[questionIndex] = inputEl.value;
                                }
                                data.sections[sectionId].lastModified = serverTimestamp();
                                transaction.set(userDocRef, data);
                            }
                        }
                    });
                } catch (error) {
                    console.error("Error saving question text:", error);
                }
            }
        }, true); // Use capture phase for blur

        timerActionBtn.addEventListener('click', () => handleTimerAction(sectionDiv));
        timerInputAction.addEventListener('change', () => updateSectionFieldInFirestore(sectionId, 'timer.initialMinutes', parseInt(timerInputAction.value)));
        keyTextarea.addEventListener('input', () => updateSectionFieldInFirestore(sectionId, 'key', keyTextarea.value));
    }

    function setQuestionCountUI(sectionDiv, targetCount, questionTexts = []) {
        const tbody = sectionDiv.querySelector('tbody');
        const sectionId = sectionDiv.id;
        const numChoices = parseInt(sectionDiv.dataset.numChoices);
        tbody.innerHTML = ''; // Clear existing rows before redrawing

        for (let i = 0; i < targetCount; i++) {
            const idx = i + 1;
            const tr = document.createElement('tr');
            let cellsHTML = `<td>${idx}</td>`;
            // Add cell for question text input
            cellsHTML += `<td class="question-text-cell"><input type="text" class="question-text-input w-full bg-gray-700 p-1 rounded border border-gray-600" placeholder="Optional: Type question here..." value="${questionTexts[i] || ''}"></td>`;
            for (let j = 0; j < numChoices; j++) {
                cellsHTML += `<td><label><input type="radio" name="${sectionId}_q${idx}" value="${CHOICES_LABELS[j]}"></label></td>`;
            }
            tr.innerHTML = cellsHTML;
            tbody.appendChild(tr);
        }
    }

    async function updateSectionFieldInFirestore(sectionId, fieldPath, value) {
        if (!userId) return;
        const userDocRef = getUserDataRef();
        if (!userDocRef) return;

        const updatePayload = {};
        updatePayload[`sections.${sectionId}.${fieldPath}`] = value;
        updatePayload[`sections.${sectionId}.lastModified`] = serverTimestamp();

        try {
            await updateDoc(userDocRef, updatePayload);
            // console.log(`Field ${fieldPath} updated for section ${sectionId}`);
        } catch (error) {
            console.error(`Error updating field ${fieldPath} for section ${sectionId}:`, error);
            // Potentially revert UI change or show error
        }
    }

    async function handleBulkAdd() {
        const value = bulkSectionInput.value.trim();
        if (!value) return;

        const entries = value.split(/[,|\\]+/);
        for (const entry of entries) { // Use for...of for async operations within loop if needed
            const match = entry.trim().match(/(.+?)\s+(\d+)(?:\s*\((A-[CDE])\))?$/i);
            if (match) {
                const name = match[1].trim();
                const count = parseInt(match[2]);
                let numChoices = 5;
                if (match[3]) {
                    const choiceRange = match[3].toUpperCase();
                    if (choiceRange === 'A-C') numChoices = 3;
                    else if (choiceRange === 'A-D') numChoices = 4;
                }

                if (count <= 0) continue;

                // Check if section with this label already exists
                let existingSectionId = null;
                const allSections = sectionsContainer.children;
                for(let secDiv of allSections) {
                    if(secDiv.querySelector('h2.editable-title').textContent.trim() === name) {
                        existingSectionId = secDiv.id;
                        break;
                    }
                }

                if (existingSectionId) {
                    // Update existing section
                    const sectionDiv = document.getElementById(existingSectionId);
                    const currentNumChoices = parseInt(sectionDiv.dataset.numChoices);
                    if (currentNumChoices !== numChoices) {
                        sectionDiv.dataset.numChoices = numChoices;
                        updateTableHeaders(sectionDiv, numChoices);
                        // Clear radio selections as choices changed
                        sectionDiv.querySelectorAll('input[type="radio"]').forEach(radio => radio.checked = false);
                        sectionDiv.querySelectorAll('td.selected').forEach(td => td.classList.remove('selected'));
                        await updateSectionFieldInFirestore(existingSectionId, 'numChoices', numChoices);
                        // Also clear selected answers in Firestore for this section
                        const questions = Array(count).fill(null).map(() => ({selected: null, text: ""}));
                        await updateSectionFieldInFirestore(existingSectionId, 'questions', questions);
                    }
                    const questionTexts = Array.from(sectionDiv.querySelectorAll('.question-text-input')).map(inp => inp.value);
                    const newQuestionTexts = Array(count).fill("").map((_,i) => questionTexts[i] || "");
                    setQuestionCountUI(sectionDiv, count, newQuestionTexts);
                    sectionDiv.querySelector('.question-input-field').value = count;
                    const questions = Array(count).fill(null).map((_,i) => ({selected: null, text: newQuestionTexts[i]}));
                    await updateSectionFieldInFirestore(existingSectionId, 'questions', questions);
                    await updateSectionFieldInFirestore(existingSectionId, 'questionTexts', newQuestionTexts);

                } else {
                    // Add new section
                    await addSectionToUIAndFirestore(name, numChoices, Array(count).fill({selected: null, text: ""}), "", null, null, Array(count).fill(""));
                }
            }
        }
        bulkSectionInput.value = ''; // Firestore save is handled by addSectionToUIAndFirestore or updateSectionFieldInFirestore
    }

    async function handleClearAllSections() {
        if (!userId) return;
        const userDocRef = getUserDataRef();
        if (!userDocRef) return;

        try {
            await updateDoc(userDocRef, { sections: {}, sectionCounter: 0 }); // Reset sections map and counter
            sectionsContainer.innerHTML = ''; // Clear UI
            sectionCounter = 0;
            updateSectionNavigator();
            updateTargetSectionForAiKeyExtractionDropdown();
            console.log("All sections cleared from Firestore and UI.");
        } catch (error) {
            console.error("Error clearing all sections: ", error);
            showCustomConfirm("Error", "Could not clear sections from cloud. Please try again.", () => {});
        }
    }

    async function handleClearAllData() {
        if (!userId) return;
        const userDocRef = getUserDataRef();
        if (!userDocRef) return;

        try {
            // This deletes the specific document holding the appState for this user and app
            await deleteDoc(userDocRef);
            sectionsContainer.innerHTML = '';
            records = [];
            sectionCounter = 0;
            attemptCounter = 0;
            updateRecordsDisplay();
            updateSectionNavigator();
            updateTargetSectionForAiKeyExtractionDropdown();
            showCustomConfirm("Success", "All your data for this app has been cleared from the cloud.", () => {});
            console.log("All user data cleared from Firestore.");
        } catch (error) {
            console.error("Error clearing all user data: ", error);
            showCustomConfirm("Error", "Could not clear all data from cloud. Please try again.", () => {});
        }
    }

    // --- Answer Checking ---
    function parseAnswerKey(sectionDiv) {
        const keyText = sectionDiv.querySelector('.key-input').value.trim();
        const numChoices = parseInt(sectionDiv.dataset.numChoices);
        const validChoices = CHOICES_LABELS.slice(0, numChoices);
        const key = {};

        // Try parsing "1=A 2=B" or "1.A 2.B" or "1:A 2:B" or "1 A 2 B" format
        const itemPattern = /(\d+)\s*[:=.]?\s*([A-Ea-e])/g;
        let match;
        let foundPattern = false;
        while ((match = itemPattern.exec(keyText)) !== null) {
            foundPattern = true;
            const num = parseInt(match[1]);
            const ans = match[2].toUpperCase();
            if (!isNaN(num) && validChoices.includes(ans)) {
                key[num] = ans;
            }
        }

        // If not found, try parsing space/newline separated letters "A B C D"
        if (!foundPattern) {
            const letters = keyText.split(/[\s\n,]+/).map(s => s.trim().toUpperCase());
            letters.forEach((ans, index) => {
                const num = index + 1;
                if (validChoices.includes(ans)) {
                    key[num] = ans;
                }
            });
        }
        return key;
    }

    function checkAnswers(sectionDiv) {
        const outputDisplay = sectionDiv.querySelector('.output-display');
        const key = parseAnswerKey(sectionDiv);
        const questionRows = sectionDiv.querySelectorAll('tbody tr');
        let correctCount = 0;
        let totalCount = 0;

        questionRows.forEach((row, index) => {
            const questionNumber = index + 1;
            const selectedRadio = row.querySelector(`input[name="${sectionDiv.id}_q${questionNumber}"]:checked`);
            const selectedAnswer = selectedRadio ? selectedRadio.value : null;
            const correctAnswer = key[questionNumber];

            // Reset classes
            row.querySelectorAll('td').forEach(td => td.classList.remove('correct', 'wrong', 'actual-correct'));

            if (correctAnswer) {
                totalCount++;
                // Mark the actual correct answer cell
                const correctAnswerCell = row.querySelector(`input[name="${sectionDiv.id}_q${questionNumber}"][value="${correctAnswer}"]`);
                if (correctAnswerCell) {
                    correctAnswerCell.closest('td').classList.add('actual-correct');
                }

                if (selectedAnswer) {
                    if (selectedAnswer === correctAnswer) {
                        correctCount++;
                        selectedRadio.closest('td').classList.add('correct');
                    } else {
                        selectedRadio.closest('td').classList.add('wrong');
                    }
                }
            }
        });

        if (totalCount > 0) {
            outputDisplay.textContent = `Score: ${correctCount}/${totalCount} (${((correctCount / totalCount) * 100).toFixed(2)}%)`;
        } else {
            outputDisplay.textContent = 'No answer key provided or questions found for scoring.';
        }

        // Record the attempt
        const record = {
            id: `record${Date.now()}`,
            sectionId: sectionDiv.id,
            sectionLabel: sectionDiv.querySelector('.section-title').textContent,
            timestamp: serverTimestamp(),
            score: `${correctCount}/${totalCount}`,
            percentage: totalCount > 0 ? parseFloat(((correctCount / totalCount) * 100).toFixed(2)) : 0,
            answers: Array.from(questionRows).map((row, index) => {
                const questionNumber = index + 1;
                const selectedRadio = row.querySelector(`input[name="${sectionDiv.id}_q${questionNumber}"]:checked`);
                const selectedAnswer = selectedRadio ? selectedRadio.value : null;
                const correctAnswer = key[questionNumber] || null;
                return { qNum: questionNumber, selected: selectedAnswer, correct: correctAnswer };
            })
        };
        addRecordToFirestore(record);
    }

    // --- Record Management ---
    async function addRecordToFirestore(record) {
        if (!userId) return;
        const userDocRef = getUserDataRef();
        if (!userDocRef) return;

        try {
            await runTransaction(db, async (transaction) => {
                const userDocSnap = await transaction.get(userDocRef);
                let currentData = userDocSnap.exists() ? userDocSnap.data() : { sections: {}, records: [], sectionCounter: 0, attemptCounter: 0 };
                
                if (!currentData.records) currentData.records = [];
                currentData.records.push(record);
                currentData.attemptCounter = (currentData.attemptCounter || 0) + 1;
                transaction.set(userDocRef, currentData, { merge: true });
            });
            records.push(record); // Update local cache
            updateRecordsDisplay();
            console.log("Record added to Firestore:", record.id);
        } catch (error) {
            console.error("Error adding record to Firestore: ", error);
            showCustomConfirm("Save Error", "Could not save record to cloud. Please try again.", () => {});
        }
    }

    function toggleRecordsVisibility() {
        recordsContainerEl.classList.toggle('hidden');
        toggleRecordsBtn.textContent = recordsContainerEl.classList.contains('hidden') ? 'Show Records' : 'Hide Records';
        if (!recordsContainerEl.classList.contains('hidden')) {
            updateRecordsDisplay(); // Refresh display when shown
        }
    }

    function updateRecordsDisplay() {
        recordsTableBody.innerHTML = ''; // Clear existing records
        // Sort records by timestamp, newest first
        const sortedRecords = [...records].sort((a, b) => b.timestamp - a.timestamp);

        sortedRecords.forEach((record, index) => {
            const row = recordsTableBody.insertRow();
            const date = record.timestamp ? new Date(record.timestamp.seconds * 1000) : new Date(); // Handle Firestore timestamp
            const formattedDate = date.toLocaleString();

            let detailsHTML = `<p>Section: ${record.sectionLabel}</p><p>Score: ${record.score} (${record.percentage}%)</p>`;
            detailsHTML += `<details><summary>Answers</summary><ul>`;
            record.answers.forEach(ans => {
                let status = '';
                if (ans.correct) {
                    if (ans.selected === ans.correct) {
                        status = '<span style="color: green;"></span>';
                    } else if (ans.selected) {
                        status = '<span style="color: red;"></span>';
                    } else {
                        status = '<span style="color: orange;">-</span>'; // Not answered
                    }
                    detailsHTML += `<li>Q${ans.qNum}: Selected ${ans.selected || 'N/A'}, Correct ${ans.correct} ${status}</li>`;
                } else {
                     detailsHTML += `<li>Q${ans.qNum}: Selected ${ans.selected || 'N/A'} (No key)</li>`;
                }
            });
            detailsHTML += `</ul></details>`;


            row.innerHTML = `
                <td>${sortedRecords.length - index}</td>
                <td>${formattedDate}</td>
                <td>${detailsHTML}</td>
                <td>
                    <button class="deleteRecordBtn danger" data-record-id="${record.id}">Delete</button>
                </td>
            `;
        });

        recordsTableBody.querySelectorAll('.deleteRecordBtn').forEach(button => {
            button.addEventListener('click', async (e) => {
                const recordId = e.target.dataset.recordId;
                showCustomConfirm("Delete Record", "Are you sure you want to delete this attempt record?", async () => {
                    if (!userId) return;
                    const userDocRef = getUserDataRef();
                    if (!userDocRef) return;

                    try {
                        await runTransaction(db, async (transaction) => {
                            const userDocSnap = await transaction.get(userDocRef);
                            if (userDocSnap.exists()) {
                                const currentData = userDocSnap.data();
                                if (currentData.records) {
                                    currentData.records = currentData.records.filter(r => r.id !== recordId);
                                    transaction.set(userDocRef, currentData);
                                }
                            }
                        });
                        records = records.filter(r => r.id !== recordId); // Update local cache
                        updateRecordsDisplay(); // Refresh display
                        console.log("Record deleted from Firestore:", recordId);
                    } catch (error) {
                        console.error("Error deleting record from Firestore: ", error);
                        showCustomConfirm("Delete Error", "Could not delete record from cloud. Please try again.", () => {});
                    }
                });
            });
        });
    }

    async function handleResetRecordAll() {
        if (!userId) return;
        
        // Loop through all sections, check answers, record, and reset
        const allSections = document.querySelectorAll('.section');
        for (const sectionDiv of allSections) {
            checkAnswers(sectionDiv); // This will also call addRecordToFirestore
            // Reset selected answers in UI
            sectionDiv.querySelectorAll('input[type="radio"]:checked').forEach(radio => {
                radio.checked = false;
                radio.closest('td').classList.remove('selected');
            });
            // Reset visual feedback
            sectionDiv.querySelectorAll('.correct, .wrong, .actual-correct').forEach(el => {
                el.classList.remove('correct', 'wrong', 'actual-correct');
            });
            sectionDiv.querySelector('.output-display').textContent = '';

            // Reset selected answers in Firestore for this section
            const sectionId = sectionDiv.id;
            const userDocRef = getUserDataRef();
            if (userDocRef) {
                try {
                    await runTransaction(db, async (transaction) => {
                        const docSnap = await transaction.get(userDocRef);
                        if (docSnap.exists()) {
                            const data = docSnap.data();
                            if (data.sections && data.sections[sectionId]) {
                                data.sections[sectionId].questions.forEach(q => q.selected = null);
                                data.sections[sectionId].lastModified = serverTimestamp();
                                transaction.set(userDocRef, data);
                            }
                        }
                    });
                } catch (error) {
                    console.error(`Error resetting questions for section ${sectionId}:`, error);
                }
            }
        }
        showCustomConfirm("Operation Complete", "All sections scored, recorded, and reset.", () => {});
    }


    function exportRecordsToCSV() {
        if (records.length === 0) {
            alert("No records to export.");
            return;
        }

        let csvContent = "data:text/csv;charset=utf-8,";
        
        // CSV Headers
        csvContent += "Attempt,Date/Time,Section Label,Score,Percentage,Question Number,Selected Answer,Correct Answer\n";

        records.forEach(record => {
            const date = record.timestamp ? new Date(record.timestamp.seconds * 1000) : new Date();
            const formattedDate = date.toLocaleString();
            const sectionLabel = `"${record.sectionLabel.replace(/"/g, '""')}"`; // Handle commas/quotes in label
            const score = record.score;
            const percentage = record.percentage;

            record.answers.forEach(ans => {
                const qNum = ans.qNum;
                const selected = ans.selected || '';
                const correct = ans.correct || '';
                csvContent += `${record.id},${formattedDate},${sectionLabel},${score},${percentage},${qNum},${selected},${correct}\n`;
            });
        });

        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", `kewnric_learning_tool_records_${new Date().toISOString().slice(0,10)}.csv`);
        document.body.appendChild(link); // Required for Firefox
        link.click();
        document.body.removeChild(link);
    }

    // --- Data Loading from Firestore ---
    async function loadStateFromFirestore() {
        if (!userId) return;

        const userDocRef = getUserDataRef();
        if (!userDocRef) {
            showAuthStatus("User data reference not available.", "error");
            return;
        }

        showAuthStatus("Loading data...", "loading");
        
        // Set up a real-time listener for the user's appState document
        if (unsubscribeSections) {
            unsubscribeSections(); // Unsubscribe previous listener if exists
        }

        unsubscribeSections = onSnapshot(userDocRef, (docSnap) => {
            if (docSnap.exists()) {
                const data = docSnap.data();
                console.log("Firestore data loaded:", data);
                
                // Clear current UI before rendering loaded data
                sectionsContainer.innerHTML = '';
                records = [];
                sectionCounter = 0;
                attemptCounter = 0;

                // Load sections
                if (data.sections) {
                    // Sort sections by createdAt or lastModified for consistent display
                    const sortedSectionIds = Object.keys(data.sections).sort((a, b) => {
                        const sectionA = data.sections[a];
                        const sectionB = data.sections[b];
                        const timeA = sectionA.createdAt ? sectionA.createdAt.seconds : 0;
                        const timeB = sectionB.createdAt ? sectionB.createdAt.seconds : 0;
                        return timeA - timeB; // Ascending order by creation time
                    });

                    sortedSectionIds.forEach(sectionId => {
                        const sectionData = data.sections[sectionId];
                        // Ensure required fields exist, provide defaults if missing
                        const questions = sectionData.questions || Array(3).fill({ selected: null, text: "" });
                        const questionTexts = sectionData.questionTexts || questions.map(q => q.text || "");
                        addSectionToDOM({
                            id: sectionData.id || sectionId, // Prefer the ID stored in sectionData, fallback to map key
                            label: sectionData.label || `Section ${Object.keys(data.sections).indexOf(sectionId) + 1}`,
                            numChoices: sectionData.numChoices || 5,
                            key: sectionData.key || "",
                            questions: questions,
                            questionTexts: questionTexts,
                            timer: sectionData.timer || null // Pass timer state
                        });
                    });
                    sectionCounter = data.sectionCounter || Object.keys(data.sections).length;
                }

                // Load records
                if (data.records) {
                    records = data.records;
                    attemptCounter = data.attemptCounter || records.length;
                    updateRecordsDisplay();
                }

                updateSectionNavigator();
                updateTargetSectionForAiKeyExtractionDropdown();
                showAuthStatus("Data loaded successfully.", "success");

            } else {
                console.log("No existing data for this user in Firestore.");
                showAuthStatus("No saved data found. Start adding sections!", "info");
                // Clear UI and local state if no data exists in Firestore for the user
                sectionsContainer.innerHTML = '';
                records = [];
                sectionCounter = 0;
                attemptCounter = 0;
                updateRecordsDisplay();
                updateSectionNavigator();
                updateTargetSectionForAiKeyExtractionDropdown();
            }
        }, (error) => {
            console.error("Error listening to Firestore data:", error);
            showAuthStatus("Error loading data. Check console.", "error");
            // If there's an error, assume no data loaded and reset UI
            sectionsContainer.innerHTML = '';
            records = [];
            sectionCounter = 0;
            attemptCounter = 0;
            updateRecordsDisplay();
            updateSectionNavigator();
            updateTargetSectionForAiKeyExtractionDropdown();
        });
    }

    // --- Section Navigator and AI Target Section Dropdowns ---
    function updateSectionNavigator() {
        sectionNavigator.innerHTML = '<option value="">-- Select Section --</option>';
        const currentSections = sectionsContainer.querySelectorAll('.section');
        currentSections.forEach(sectionDiv => {
            const id = sectionDiv.id;
            const label = sectionDiv.querySelector('.section-title').textContent;
            const option = document.createElement('option');
            option.value = id;
            option.textContent = label;
            sectionNavigator.appendChild(option);
        });
    }

    function updateTargetSectionForAiKeyExtractionDropdown() {
        targetSectionForKey.innerHTML = '<option value="">-- Select Section --</option>';
        const currentSections = sectionsContainer.querySelectorAll('.section');
        currentSections.forEach(sectionDiv => {
            const id = sectionDiv.id;
            const label = sectionDiv.querySelector('.section-title').textContent;
            const option = document.createElement('option');
            option.value = id;
            option.textContent = label;
            targetSectionForKey.appendChild(option);
        });
    }

    // --- Timer Functions ---
    // Stores all active timer intervals so they can be cleared
    const activeTimers = {};

    function startTimer(sectionDiv, initialMinutes, remainingTimeOnPause = 0) {
        const sectionId = sectionDiv.id;
        const timerDisplay = sectionDiv.querySelector('.timerDisplay');
        const timerActionBtn = sectionDiv.querySelector('.timerActionBtn');
        const checkAnsBtn = sectionDiv.querySelector('.checkAnsBtn');
        const numChoices = parseInt(sectionDiv.dataset.numChoices);

        // Clear any existing timer for this section
        if (activeTimers[sectionId]) {
            clearInterval(activeTimers[sectionId].interval);
            delete activeTimers[sectionId];
        }

        let totalSeconds = initialMinutes * 60;
        if (remainingTimeOnPause > 0) {
            totalSeconds = remainingTimeOnPause;
        }

        const endTime = Date.now() + totalSeconds * 1000;

        // Save initial timer state to Firestore
        updateSectionFieldInFirestore(sectionId, 'timer', {
            initialMinutes: initialMinutes,
            endTime: endTime,
            isPaused: false,
            remainingTimeOnPause: 0,
            timeLeft: totalSeconds // Store current time left
        });

        timerActionBtn.textContent = 'Pause Timer';
        timerActionBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
        timerActionBtn.classList.add('bg-yellow-500', 'hover:bg-yellow-600', 'text-black');
        sectionDiv.classList.remove('overdue'); // Remove overdue class if starting fresh

        // Immediately update button style for check answers
        checkAnsBtn.classList.add('hidden'); // Hide check answers when timer is active

        const interval = setInterval(() => {
            const now = Date.now();
            let timeLeft = Math.round((endTime - now) / 1000);

            if (timeLeft < 0) {
                timeLeft = 0; // Ensure it doesn't go negative
            }
            
            timerDisplay.textContent = formatTime(timeLeft);
            updateSectionFieldInFirestore(sectionId, 'timer.timeLeft', timeLeft); // Update timeLeft in Firestore

            if (timeLeft <= 0) {
                clearInterval(interval);
                timerDisplay.textContent = "Time's up!";
                timerActionBtn.textContent = 'Start Timer';
                timerActionBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'text-black');
                timerActionBtn.classList.add('bg-blue-500', 'hover:bg-blue-600');
                sectionDiv.classList.add('overdue'); // Add visual cue for overdue
                checkAnsBtn.classList.remove('hidden'); // Show check answers again
                // Update final timer state in Firestore
                updateSectionFieldInFirestore(sectionId, 'timer', {
                    initialMinutes: initialMinutes, // Retain original initial minutes
                    endTime: null, // Clear end time
                    isPaused: false,
                    remainingTimeOnPause: 0,
                    timeLeft: 0 // Set timeLeft to 0
                });
                delete activeTimers[sectionId];
            }
        }, 1000);

        activeTimers[sectionId] = {
            interval: interval,
            initialMinutes: initialMinutes,
            endTime: endTime
        };
    }

    function pauseTimer(sectionDiv) {
        const sectionId = sectionDiv.id;
        const timerData = activeTimers[sectionId];
        if (timerData) {
            clearInterval(timerData.interval);
            const timerActionBtn = sectionDiv.querySelector('.timerActionBtn');
            const checkAnsBtn = sectionDiv.querySelector('.checkAnsBtn');
            timerActionBtn.textContent = 'Resume Timer';
            timerActionBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'text-black');
            timerActionBtn.classList.add('bg-green-500', 'hover:bg-green-600');
            checkAnsBtn.classList.remove('hidden'); // Show check answers when paused

            const now = Date.now();
            const remainingTimeOnPause = Math.round((timerData.endTime - now) / 1000);

            updateSectionFieldInFirestore(sectionId, 'timer', {
                initialMinutes: timerData.initialMinutes,
                endTime: timerData.endTime, // Keep original end time for consistency, though not strictly needed when paused
                isPaused: true,
                remainingTimeOnPause: remainingTimeOnPause,
                timeLeft: remainingTimeOnPause // Store remaining time
            });
            delete activeTimers[sectionId]; // Remove from active timers, but keep state in Firestore
        }
    }

    function resetTimer(sectionDiv) {
        const sectionId = sectionDiv.id;
        if (activeTimers[sectionId]) {
            clearInterval(activeTimers[sectionId].interval);
            delete activeTimers[sectionId];
        }
        const timerDisplay = sectionDiv.querySelector('.timerDisplay');
        const timerActionBtn = sectionDiv.querySelector('.timerActionBtn');
        const timerInput = sectionDiv.querySelector('.timer-input');
        const checkAnsBtn = sectionDiv.querySelector('.checkAnsBtn');

        timerDisplay.textContent = '';
        timerActionBtn.textContent = 'Start Timer';
        timerActionBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'text-black', 'bg-green-500', 'hover:bg-green-600');
        timerActionBtn.classList.add('bg-blue-500', 'hover:bg-blue-600');
        sectionDiv.classList.remove('overdue');
        checkAnsBtn.classList.remove('hidden'); // Always show check answers after reset

        // Clear timer state in Firestore
        updateSectionFieldInFirestore(sectionId, 'timer', {
            initialMinutes: parseInt(timerInput.value), // Retain the value from input
            endTime: null,
            isPaused: false,
            remainingTimeOnPause: 0,
            timeLeft: null
        });
    }

    function restoreTimer(sectionDiv, timerState) {
        if (timerState && timerState.endTime && !timerState.isPaused) {
            const now = Date.now();
            const timeLeftSeconds = Math.round((timerState.endTime - now) / 1000);
            if (timeLeftSeconds > 0) {
                startTimer(sectionDiv, timerState.initialMinutes, timeLeftSeconds); // Resume active timer
            } else {
                // Timer has already expired
                const timerDisplay = sectionDiv.querySelector('.timerDisplay');
                const timerActionBtn = sectionDiv.querySelector('.timerActionBtn');
                const checkAnsBtn = sectionDiv.querySelector('.checkAnsBtn');
                timerDisplay.textContent = "Time's up!";
                timerActionBtn.textContent = 'Start Timer';
                timerActionBtn.classList.remove('bg-yellow-500', 'hover:bg-yellow-600', 'text-black');
                timerActionBtn.classList.add('bg-blue-500', 'hover:bg-blue-600');
                sectionDiv.classList.add('overdue');
                checkAnsBtn.classList.remove('hidden');
                // Update Firestore to reflect expired state if it wasn't already
                updateSectionFieldInFirestore(sectionDiv.id, 'timer', {
                    initialMinutes: timerState.initialMinutes,
                    endTime: null,
                    isPaused: false,
                    remainingTimeOnPause: 0,
                    timeLeft: 0
                });
            }
        } else if (timerState && timerState.isPaused && timerState.remainingTimeOnPause > 0) {
            // Timer was paused, set UI to resume state
            const timerDisplay = sectionDiv.querySelector('.timerDisplay');
            const timerActionBtn = sectionDiv.querySelector('.timerActionBtn');
            const checkAnsBtn = sectionDiv.querySelector('.checkAnsBtn');

            timerDisplay.textContent = formatTime(timerState.remainingTimeOnPause);
            timerActionBtn.textContent = 'Resume Timer';
            timerActionBtn.classList.remove('bg-blue-500', 'hover:bg-blue-600');
            timerActionBtn.classList.add('bg-green-500', 'hover:bg-green-600');
            checkAnsBtn.classList.remove('hidden'); // Show check answers when paused

        } else if (timerState && timerState.initialMinutes) {
            // Timer exists but is not active/paused (e.g., just set, or reset after expiration)
            const timerDisplay = sectionDiv.querySelector('.timerDisplay');
            timerDisplay.textContent = formatTime(timerState.initialMinutes * 60);
        }
    }


    function handleTimerAction(sectionDiv) {
        const sectionId = sectionDiv.id;
        const timerInput = sectionDiv.querySelector('.timer-input');
        const timerActionBtn = sectionDiv.querySelector('.timerActionBtn');
        const currentTimerState = activeTimers[sectionId]; // Check if timer is currently active in JS

        if (currentTimerState) {
            // If timer is active, pause it
            pauseTimer(sectionDiv);
        } else if (timerActionBtn.textContent === 'Resume Timer') {
            // If button says 'Resume', it means it was paused, so resume
            const timerStateFromFirestore = sectionDiv.dataset.timerState ? JSON.parse(sectionDiv.dataset.timerState) : null;
            if (timerStateFromFirestore && timerStateFromFirestore.isPaused && timerStateFromFirestore.remainingTimeOnPause > 0) {
                startTimer(sectionDiv, timerStateFromFirestore.initialMinutes, timerStateFromFirestore.remainingTimeOnPause);
            } else {
                // Fallback if data-timerState is missing or incorrect
                const initialMinutes = parseInt(timerInput.value);
                if (initialMinutes > 0) {
                    startTimer(sectionDiv, initialMinutes);
                } else {
                    alert("Please set a timer duration.");
                }
            }
        } else {
            // If button says 'Start Timer', begin a new timer
            const initialMinutes = parseInt(timerInput.value);
            if (initialMinutes > 0) {
                startTimer(sectionDiv, initialMinutes);
            } else {
                alert("Please set a timer duration.");
            }
        }
    }

    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        const paddedMinutes = String(minutes).padStart(2, '0');
        const paddedSeconds = String(remainingSeconds).padStart(2, '0');
        return `${paddedMinutes}:${paddedSeconds}`;
    }

    // --- AI Integration (Question Extraction) ---
    async function handleExtractAnswerKey() {
        const text = textToExtractKey.value.trim();
        const sectionId = targetSectionForKey.value;

        if (!text) {
            aiStatusMessage.textContent = "Please paste text to extract the answer key.";
            return;
        }
        if (!sectionId) {
            aiStatusMessage.textContent = "Please select a target section for the answer key.";
            return;
        }

        aiLoadingIndicator.classList.remove('hidden');
        aiStatusMessage.textContent = "Extracting answer key...";

        try {
            const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=YOUR_GEMINI_API_KEY', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: `Extract only the answer key from the following text. The format should be "1=A\n2=B\n3=C" or simply "A B C D E" if it's a continuous list without question numbers. Prioritize numbered lists if present. Do not include any other text or explanation. If no clear key is found, return "NO_KEY_FOUND".\n\nText: ${text}`
                        }]
                    }]
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API error: ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`);
            }

            const data = await response.json();
            const extractedKey = data.candidates[0].content.parts[0].text.trim();

            const sectionDiv = document.getElementById(sectionId);
            const keyTextarea = sectionDiv.querySelector('.key-input');
            
            if (extractedKey === "NO_KEY_FOUND") {
                aiStatusMessage.textContent = "No clear answer key could be extracted.";
            } else {
                keyTextarea.value = extractedKey;
                await updateSectionFieldInFirestore(sectionId, 'key', extractedKey);
                aiStatusMessage.textContent = "Answer key extracted and saved.";
            }
            textToExtractKey.value = ""; // Clear input

        } catch (error) {
            aiStatusMessage.textContent = 'Failed to extract answer key. Check console for details or try rephrasing input.';
            console.error("Error during key extraction:", error);
        } finally {
            aiLoadingIndicator.classList.add('hidden');
        }
    }

    async function handleExtractQuestionsAndKey() {
        const text = textToExtractAll.value.trim();
        if (!text) {
            aiStatusMessage.textContent = "Please paste text containing questions and answers.";
            return;
        }

        aiLoadingIndicator.classList.remove('hidden');
        aiStatusMessage.textContent = "Extracting questions and answer key...";

        try {
            const prompt = `Extract Multiple Choice Questions (MCQs) and their answer key from the following text.
            
            For each question, provide:
            - questionText: The full question text.
            - choices: An array of choice objects, each with 'label' (A, B, C, D, E) and 'text' (the choice content).
            - correctAnswerLetter: The letter (A, B, C, D, E) corresponding to the correct answer.

            The output should be a single JSON array of question objects. Ensure proper JSON formatting. If no clear questions or answers are found, return an empty JSON array: [].

            Example of expected JSON structure:
            [
              {
                "questionText": "What is the capital of France?",
                "choices": [
                  {"label": "A", "text": "Berlin"},
                  {"label": "B", "text": "Madrid"},
                  {"label": "C", "text": "Paris"},
                  {"label": "D", "text": "Rome"}
                ],
                "correctAnswerLetter": "C"
              },
              {
                "questionText": "Which planet is known as the Red Planet?",
                "choices": [
                  {"label": "A", "text": "Earth"},
                  {"label": "B", "text": "Mars"},
                  {"label": "C", "text": "Jupiter"},
                  {"label": "D", "text": "Venus"}
                ],
                "correctAnswerLetter": "B"
              }
            ]

            Text to extract from:\n\n${text}`;

            const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=YOUR_GEMINI_API_KEY', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: prompt
                        }]
                    }]
                }),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API error: ${response.status} ${response.statusText} - ${JSON.stringify(errorData)}`);
            }

            const data = await response.json();
            const rawJsonString = data.candidates[0].content.parts[0].text.trim();
            let questionsFromAI = [];

            // Attempt to parse the JSON. The model might return extra markdown or text.
            try {
                // Try to find the JSON part in the response (e.g., if it's wrapped in ```json ... ```)
                const jsonMatch = rawJsonString.match(/```json\n([\s\S]*?)\n```/);
                if (jsonMatch && jsonMatch[1]) {
                    questionsFromAI = JSON.parse(jsonMatch[1]);
                } else {
                    questionsFromAI = JSON.parse(rawJsonString); // Direct parse if no markdown wrapper
                }
            } catch (jsonError) {
                console.error("Failed to parse AI response as JSON:", jsonError);
                aiStatusMessage.textContent = 'AI response was not valid JSON. Please try rephrasing input.';
                aiLoadingIndicator.classList.add('hidden');
                return;
            }


            if (!Array.isArray(questionsFromAI) || questionsFromAI.length === 0) {
                aiStatusMessage.textContent = "No questions could be extracted. The AI returned an empty or invalid list.";
                aiLoadingIndicator.classList.add('hidden');
                return;
            }

            const sectionTitle = text.split('\n')[0].substring(0, 50).trim() || "AI Extracted Section";
            // Determine number of choices based on extracted questions
            let numChoices = 3; // Min
            if (questionsFromAI.length > 0) {
                 numChoices = questionsFromAI.reduce((max, q) => Math.max(max, q.choices.length), 0);
                 if (numChoices < 3) numChoices = 3; // Ensure at least 3
                 if (numChoices > 5) numChoices = 5; // Cap at 5
            }


            const questionTextsForSection = questionsFromAI.map(q => q.questionText);
            const answerKeyArray = questionsFromAI.map((q, index) => `${index + 1}=${q.correctAnswerLetter.toUpperCase()}`);
            const answerKeyString = answerKeyArray.join('\n');

            const questionsForSection = questionsFromAI.map(q => ({
                selected: null, // No answers selected initially
                text: q.questionText
            }));

            // Add new section with extracted data
            await addSectionToUIAndFirestore(sectionTitle, numChoices, questionsForSection, answerKeyString, null, null, questionTextsForSection);
            
            aiStatusMessage.textContent = `Successfully extracted ${questionsFromAI.length} questions and created new section: "${sectionTitle}"`;
            textToExtractAll.value = ""; // Clear input
        } catch (error) {
            aiStatusMessage.textContent = 'Failed to extract questions. Check console for details or try rephrasing input.';
            console.error("Error during full extraction:", error);
        } finally {
            aiLoadingIndicator.classList.add('hidden');
        }
    }
</script>
</body>
</html>
